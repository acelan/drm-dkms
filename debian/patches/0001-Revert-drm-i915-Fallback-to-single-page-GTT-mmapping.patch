From 852f4398bbd3f18d723253af56d7b5c4ab1206b1 Mon Sep 17 00:00:00 2001
From: Timo Aaltonen <timo.aaltonen@canonical.com>
Date: Tue, 12 Sep 2017 10:58:39 +0300
Subject: [PATCH] Revert "drm/i915: Fallback to single page GTT mmappings for
 relocations"

This reverts commit e8cb909ac3abbcac5184825638903a2b9a225725.
---
 drivers/gpu/drm/i915/i915_gem_execbuffer.c | 62 ++++++------------------------
 1 file changed, 11 insertions(+), 51 deletions(-)

diff --git a/drivers/gpu/drm/i915/i915_gem_execbuffer.c b/drivers/gpu/drm/i915/i915_gem_execbuffer.c
index 65c3f05..4677317 100644
--- a/drivers/gpu/drm/i915/i915_gem_execbuffer.c
+++ b/drivers/gpu/drm/i915/i915_gem_execbuffer.c
@@ -333,7 +333,6 @@ static void reloc_cache_init(struct reloc_cache *cache,
 	cache->vaddr = 0;
 	cache->i915 = i915;
 	cache->use_64bit_reloc = INTEL_GEN(cache->i915) >= 8;
-	cache->node.allocated = false;
 }
 
 static inline void *unmask_page(unsigned long p)
@@ -363,19 +362,8 @@ static void reloc_cache_fini(struct reloc_cache *cache)
 		kunmap_atomic(vaddr);
 		i915_gem_obj_finish_shmem_access((struct drm_i915_gem_object *)cache->node.mm);
 	} else {
-		wmb();
 		io_mapping_unmap_atomic((void __iomem *)vaddr);
-		if (cache->node.allocated) {
-			struct i915_ggtt *ggtt = &cache->i915->ggtt;
-
-			ggtt->base.clear_range(&ggtt->base,
-					       cache->node.start,
-					       cache->node.size,
-					       true);
-			drm_mm_remove_node(&cache->node);
-		} else {
-			i915_vma_unpin((struct i915_vma *)cache->node.mm);
-		}
+		i915_vma_unpin((struct i915_vma *)cache->node.mm);
 	}
 }
 
@@ -415,19 +403,8 @@ static void *reloc_iomap(struct drm_i915_gem_object *obj,
 			 struct reloc_cache *cache,
 			 int page)
 {
-	struct i915_ggtt *ggtt = &cache->i915->ggtt;
-	unsigned long offset;
 	void *vaddr;
 
-	if (cache->node.allocated) {
-		wmb();
-		ggtt->base.insert_page(&ggtt->base,
-				       i915_gem_object_get_dma_address(obj, page),
-				       cache->node.start, I915_CACHE_NONE, 0);
-		cache->page = page;
-		return unmask_page(cache->vaddr);
-	}
-
 	if (cache->vaddr) {
 		io_mapping_unmap_atomic(unmask_page(cache->vaddr));
 	} else {
@@ -443,38 +420,21 @@ static void *reloc_iomap(struct drm_i915_gem_object *obj,
 
 		vma = i915_gem_object_ggtt_pin(obj, NULL, 0, 0,
 					       PIN_MAPPABLE | PIN_NONBLOCK);
-		if (IS_ERR(vma)) {
-			memset(&cache->node, 0, sizeof(cache->node));
-			ret = drm_mm_insert_node_in_range_generic
-				(&ggtt->base.mm, &cache->node,
-				 4096, 0, 0,
-				 0, ggtt->mappable_end,
-				 DRM_MM_SEARCH_DEFAULT,
-				 DRM_MM_CREATE_DEFAULT);
-			if (ret) /* no inactive aperture space, use cpu reloc */
-				return NULL;
-		} else {
-			ret = i915_vma_put_fence(vma);
-			if (ret) {
-				i915_vma_unpin(vma);
-				return ERR_PTR(ret);
-			}
+		if (IS_ERR(vma))
+			return NULL;
 
-			cache->node.start = vma->node.start;
-			cache->node.mm = (void *)vma;
+		ret = i915_gem_object_put_fence(obj);
+		if (ret) {
+			i915_vma_unpin(vma);
+			return ERR_PTR(ret);
 		}
-	}
 
-	offset = cache->node.start;
-	if (cache->node.allocated) {
-		ggtt->base.insert_page(&ggtt->base,
-				       i915_gem_object_get_dma_address(obj, page),
-				       offset, I915_CACHE_NONE, 0);
-	} else {
-		offset += page << PAGE_SHIFT;
+		cache->node.start = vma->node.start;
+		cache->node.mm = (void *)vma;
 	}
 
-	vaddr = io_mapping_map_atomic_wc(cache->i915->ggtt.mappable, offset);
+	vaddr = io_mapping_map_atomic_wc(cache->i915->ggtt.mappable,
+					 cache->node.start + (page << PAGE_SHIFT));
 	cache->page = page;
 	cache->vaddr = (unsigned long)vaddr;
 
-- 
2.7.4

