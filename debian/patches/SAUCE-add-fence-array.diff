--- /dev/null
+++ b/include/fence-array.h
@@ -0,0 +1,83 @@
+/*
+ * fence-array: aggregates fence to be waited together
+ *
+ * Copyright (C) 2016 Collabora Ltd
+ * Copyright (C) 2016 Advanced Micro Devices, Inc.
+ * Authors:
+ *	Gustavo Padovan <gustavo@padovan.org>
+ *	Christian KÃ¶nig <christian.koenig@amd.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef __LINUX_FENCE_ARRAY_H
+#define __LINUX_FENCE_ARRAY_H
+
+#include <linux/fence.h>
+
+/**
+ * struct fence_array_cb - callback helper for fence array
+ * @cb: fence callback structure for signaling
+ * @array: reference to the parent fence array object
+ */
+struct fence_array_cb {
+	struct fence_cb cb;
+	struct fence_array *array;
+};
+
+/**
+ * struct fence_array - fence to represent an array of fences
+ * @base: fence base class
+ * @lock: spinlock for fence handling
+ * @num_fences: number of fences in the array
+ * @num_pending: fences in the array still pending
+ * @fences: array of the fences
+ */
+struct fence_array {
+	struct fence base;
+
+	spinlock_t lock;
+	unsigned num_fences;
+	atomic_t num_pending;
+	struct fence **fences;
+};
+
+extern const struct fence_ops fence_array_ops;
+
+/**
+ * fence_is_array - check if a fence is from the array subsclass
+ *
+ * Return true if it is a fence_array and false otherwise.
+ */
+static inline bool fence_is_array(struct fence *fence)
+{
+	return fence->ops == &fence_array_ops;
+}
+
+/**
+ * to_fence_array - cast a fence to a fence_array
+ * @fence: fence to cast to a fence_array
+ *
+ * Returns NULL if the fence is not a fence_array,
+ * or the fence_array otherwise.
+ */
+static inline struct fence_array *to_fence_array(struct fence *fence)
+{
+	if (fence->ops != &fence_array_ops)
+		return NULL;
+
+	return container_of(fence, struct fence_array, base);
+}
+
+struct fence_array *fence_array_create(int num_fences, struct fence **fences,
+				       u64 context, unsigned seqno,
+				       bool signal_on_any);
+
+#endif /* __LINUX_FENCE_ARRAY_H */
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c
@@ -25,12 +25,116 @@
  *          Alex Deucher
  *          Jerome Glisse
  */
-#include <linux/fence-array.h>
+#include <fence-array.h>
 #include <drm/drmP.h>
 #include <drm/amdgpu_drm.h>
 #include "amdgpu.h"
 #include "amdgpu_trace.h"
 
+static void fence_array_cb_func(struct fence *f, struct fence_cb *cb);
+
+static const char *fence_array_get_driver_name(struct fence *fence)
+{
+        return "fence_array";
+}
+
+static const char *fence_array_get_timeline_name(struct fence *fence)
+{
+        return "unbound";
+}
+
+static void fence_array_cb_func(struct fence *f, struct fence_cb *cb)
+{
+        struct fence_array_cb *array_cb =
+                container_of(cb, struct fence_array_cb, cb);
+        struct fence_array *array = array_cb->array;
+
+        if (atomic_dec_and_test(&array->num_pending))
+                fence_signal(&array->base);
+        fence_put(&array->base);
+}
+
+static bool fence_array_enable_signaling(struct fence *fence)
+{
+        struct fence_array *array = to_fence_array(fence);
+        struct fence_array_cb *cb = (void *)(&array[1]);
+        unsigned i;
+
+        for (i = 0; i < array->num_fences; ++i) {
+                cb[i].array = array;
+                /*
+                 * As we may report that the fence is signaled before all
+                 * callbacks are complete, we need to take an additional
+                 * reference count on the array so that we do not free it too
+                 * early. The core fence handling will only hold the reference
+                 * until we signal the array as complete (but that is now
+                 * insufficient).
+                 */
+                fence_get(&array->base);
+                if (fence_add_callback(array->fences[i], &cb[i].cb,
+                                       fence_array_cb_func)) {
+                        fence_put(&array->base);
+                        if (atomic_dec_and_test(&array->num_pending))
+                                return false;
+                }
+        }
+
+        return true;
+}
+
+static bool fence_array_signaled(struct fence *fence)
+{
+        struct fence_array *array = to_fence_array(fence);
+
+        return atomic_read(&array->num_pending) <= 0;
+}
+
+static void fence_array_release(struct fence *fence)
+{
+        struct fence_array *array = to_fence_array(fence);
+        unsigned i;
+
+        for (i = 0; i < array->num_fences; ++i)
+                fence_put(array->fences[i]);
+
+        kfree(array->fences);
+        fence_free(fence);
+}
+
+const struct fence_ops fence_array_ops = {
+        .get_driver_name = fence_array_get_driver_name,
+        .get_timeline_name = fence_array_get_timeline_name,
+        .enable_signaling = fence_array_enable_signaling,
+        .signaled = fence_array_signaled,
+        .wait = fence_default_wait,
+        .release = fence_array_release,
+};
+
+struct fence_array *fence_array_create(int num_fences, struct fence **fences,
+                                       u64 context, unsigned seqno,
+                                       bool signal_on_any)
+{
+        struct fence_array *array;
+        size_t size = sizeof(*array);
+
+        /* Allocate the callback structures behind the array. */
+        size += num_fences * sizeof(struct fence_array_cb);
+        array = kzalloc(size, GFP_KERNEL);
+        if (!array)
+                return NULL;
+
+        spin_lock_init(&array->lock);
+        fence_init(&array->base, &fence_array_ops, &array->lock,
+                   context, seqno);
+
+        array->num_fences = num_fences;
+        atomic_set(&array->num_pending, signal_on_any ? 1 : num_fences);
+        array->fences = fences;
+
+        return array;
+}
+
+
 /*
  * GPUVM
  * GPUVM is similar to the legacy gart on older asics, however
